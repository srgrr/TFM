\section{The COMPSs Programming Model}
\label{sec:compss}
COMP Superscalar (and, from now on, COMPSs) is a framework aimed to ease the development of applications for distributed infrastructures \cite{compss} \cite{Lordan2014}. A COMPSs application is typically a normal application with some special annotations and a few extra function calls in its code that transform a sequential code into a program that can run in a distributed environment.\\
\\
COMPSs applications can be written in Java, C/C++, and in Python (both 2 and 3). The Python framework is called PyCOMPSs \cite{pycompss}. All the examples and real-world usages in this project will be developed in the PyCOMPSs framework and in the Python language. However, this does not mean that all the features discussed and developed in this project are only available for PyCOMPSs. In fact, given how COMPSs is designed, the implementation of a feature for PyCOMPSs usually implies to implicitly implement it for any programming language.\\
\\
The COMPSs framework also provides users and developers with some tools and data that helps to monitor and to debug the applications and COMPSs itself. From a user point of view, a graph of the workflow and traces of the execution of applications can be generated (figures \ref{fig:graph_example}  and \ref{fig:trace_example}). Traces are generated with a combination of Extrae \footnote{https://tools.bsc.es/doc/pdf/extrae.pdf}, Paraver \cite{paraver}, and a custom implementation inside COMPSs itself. From a developer point of view, many debug information, as logging messages and stack traces, is available if runnning COMPSs with debug flags or in case COMPSs crashes.

\begin{figure}[ht!]
\centering
\includegraphics[scale = 0.45]{figures/2x2_matmul_graph.png}
\caption{A dependency graph generated by a COMPSs application. Circular nodes are tasks, octogonal edges are syncpoints, and edges are dependencies between tasks and/or syncpoints caused by some data. The labels of the edges are the identifiers of the data that causes these dependencies.}
\label{fig:graph_example}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[scale = 0.3]{figures/matmul_trace.png}
\caption{A trace generated by a COMPSs application. Each row corresponds to a process, colored segments are different tasks, and yellow tasks are network transfers between different computing nodes.}
\label{fig:trace_example}
\end{figure}

%TODO Maybe it is not that necessary
\input{compss_example.tex}

\subsection{COMPSs Components}
\label{subsec:compss_components}
COMPSs is designed, developed, and deployed in a modular way. This has some advantages:
\begin{itemize} 
\item Easier isolation of features
\item Partial COMPSs installations are possible (e.g: install COMPSs without PyCOMPSs)
\item Components can be individually replaced, leading to faster deployments
\end{itemize}
An overview of the main COMPSs components can be found in figure \ref{fig:compss_modules}. These components are also modularized, as seen in figures \ref{fig:runtime_modules} and \ref{fig:pycompss_modules}.
\begin{figure}
\centering
\includegraphics{figures/compss_modules.png}
\caption{Overview of the main COMPSs components.}
\label{fig:compss_modules}
\end{figure}

%TODO: Ask Francesc help with this one
\begin{figure}
\centering
\includegraphics{figures/pending.jpg}
\caption{Overview of the main Runtime components.}
\label{fig:runtime_modules}
\end{figure}

\begin{figure}
\centering
\includegraphics{figures/pycompss_modules.png}
\caption{Overview of the main PyCOMPSs components.}
\label{fig:pycompss_modules}
\end{figure}

This design choice also brings some unwanted problems. The main issue is isolation and concentration of knowledge of some parts in some developers, which leads to unnecessary code replication, lack of coherence of design and implementation choices between different modules, partial feature implementations (e.g: a feature that is only available in PyCOMPSs because it was developed by someone who did not know how to implement it in the runtime), and many other things. All these issues will be adressed and referred to in this document, as they appear and play an important role in our own design choices and implementations.

%TODO
\subsection{Runtime Structure}
\label{subsec:runtime_structure}

\subsection{PyCOMPSs Structure}
\label{subsec:pycompss_structure}
PyCOMPSs can be summarized as a Python Binding for COMPSs. It gives the user a way to annotate his Python code, and it internally transforms and forwards all the derived task creation requests and data to the COMPSs Runtime. Its role can be summarized as follows:
\begin{enumerate}
\item Execute the user code, both the master and the worker part
\item Implement code annotations (\verb|@task|, \verb|@binary|, etc)
\item Implement flow control mechanisms (\verb|compss_wait_on|, \verb|compss_barrier|, etc)
\item Transform the user data into something easily to transport between different machines
\end{enumerate}

\subsection{Usability vs Performance}
\label{subsec:compss_ux_vs_perf}
COMPSs has two goals: to give the not-so-expert user an easy way to make their sequential applications run in distributed environments, and to do it as efficiently as possible. Many improvements in the COMPSs framework are aimed to improve only one of these two aspects. For example, any improvement in the communication library may improve the performance of the user application, but the user will still face the same limitations and problems when using COMPSs. Adding an automatic return completion, in case the user forgot to annotate the return value of some task, may save the user a lot of debugging time, but it will have no impact in the performance of the user application.\\
\\
The COMPSs software is developed and mantained by a research team in a research center, so it may be natural to think that most of the efforts and improvements are aimed to test and develop methods, models, and algorithms that improve performance, memory usage, minimize network transfers and so on. However, COMPSs is also used by other research teams as a \textit{tool} for their own purposes. Some of these teams intend to run exotic, old, complicated applications in distributed environments. Also, these teams are usually composed of researchers from fields differents than computer science, so a lack of knowledge in parallel and distributed applications should be expected. The user-oriented features intend to help these research teams, and to make their life easier in the very complicated world of distributed computing.\\
\\
This project tries to bring something that improves COMPSs in these two directions: give something to the user that makes his life easier while making COMPSs more efficient. We do not intend to limit ourselves to give the user a way to pack some parameters in a collection. We see this feature as an opportunity to give COMPSs additional intelligence that may help to improve the performance of the framework.
