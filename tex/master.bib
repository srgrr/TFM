@article{compss,
author = {Badia, Rosa M. and Conejero, Javier and Diaz, Carlos and Ejarque, Jorge and Lezzi, Daniele and Lordan, Francesc and Ramon-Cortes Vilarrodona, Cristian and Sirvent, Raul},
year = {2015},
month = {11},
pages = {},
title = {COMP Superscalar, an interoperable programming framework},
volume = {3},
journal = {SoftwareX},
doi = {10.1016/j.softx.2015.10.004}
}

@article{pycompss,
author = {Enric Tejedor and Yolanda Becerra and Guillem Alomar and Anna Queralt and Rosa M Badia and Jordi Torres and Toni Cortes and Jes√∫s Labarta},
title ={PyCOMPSs: Parallel computational workflows in Python},
journal = {The International Journal of High Performance Computing Applications},
volume = {31},
number = {1},
pages = {66-82},
year = {2017},
doi = {10.1177/1094342015594678},

URL = { 
        https://doi.org/10.1177/1094342015594678
    
},
eprint = { 
        https://doi.org/10.1177/1094342015594678
    
}
,
    abstract = { The use of the Python programming language for scientific computing has been gaining momentum in the last years. The fact that it is compact and readable and its complete set of scientific libraries are two important characteristics that favour its adoption. Nevertheless, Python still lacks a solution for easily parallelizing generic scripts on distributed infrastructures, since the current alternatives mostly require the use of APIs for message passing or are restricted to embarrassingly parallel computations. In that sense, this paper presents PyCOMPSs, a framework that facilitates the development of parallel computational workflows in Python. In this approach, the user programs her script in a sequential fashion and decorates the functions to be run as asynchronous parallel tasks. A runtime system is in charge of exploiting the inherent concurrency of the script, detecting the data dependencies between tasks and spawning them to the available resources. Furthermore, we show how this programming model can be built on top of a Big Data storage architecture, where the data stored in the backend is abstracted and accessed from the application in the form of persistent objects. }
}

