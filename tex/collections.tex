\section{Collections in COMPSs}
\label{sec:col}
As we have seen in previous sections and examples, a COMPSs parameter is basically a regular user-code object, as a \verb|numpy.ndarray|, with additional metadata to help the COMPSs Runtime to compute any dependency between tasks induced by this particular object.\\
\\
A very common issue reported by COMPSs users is that the programming model is not able to detect dependencies induced by attributes or contents. Many examples are valid: an array \verb|[object(), some_future_object]|, an instance of a class with some attribute that is a future object... or some object that has been used in a super-object.\\
\\
The ideal solution, which consists of implementing a generic introspection algorithm, is very hard, if not impossible, to implement. Python is a language with no types, some objects can be modified if iterated, many others have no easy way to list its internal attributes... the list is almost endless. However, this use case is pretty common, so something must be done. An interesting observation is that any sub object will necesarrily have the same direction as the super object sent as a task parameter. This represents an edge that can be exploited to obtain some performance. These two reasons are more than enough to consider implementing some kind 

\subsection{Collections as Input Parameters}
\label{subsec:col_in}
The first step in this implementation consists of enabling the COMPSs Programming Model to accept collections fully composed of input parameters.

\subsection{Collections of Collections: (Matrices)}
\label{subsec:col_depth}

\subsection{Collections as INOUT Parameters}
\label{subsec:col_inout}

\subsection{Some practical examples}
\label{subsec:col_examples}
\input{hyperloglog.tex}