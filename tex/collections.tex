\section{Collections in COMPSs}
\label{sec:col}
As we have seen in previous sections and examples, a COMPSs parameter is basically a regular user-code object, as a \verb|numpy.ndarray|, with additional metadata to help the COMPSs Runtime to compute any dependency between tasks induced by this particular object, keep track of its locations, and so on.\\
\\
A very common issue reported by COMPSs users is that the programming model is not able to detect dependencies induced by attributes or contents. Many examples are valid: an array \verb|[object(), some_future_object]|, an instance of a class with some attribute that is a future object... or some object that has been used in a super-object. If the container is used as a COMPSs parameter, no synchronization of the sub-object will ever happen, as the programming model won't know about it.\\
\\
The ideal solution, a generic introspection algorithm, is very hard, if not impossible, to implement. Python is dynamically typed language, some objects can be modified if iterated, many others have no easy way to list its internal attributes, circular references can happen... the list is almost endless. Another obstacle is object reconstruction. Let's consider the following code:
\begin{verbatim}
A = MyClass()
A.attribute = some_pycompss_task()
another_pycompss_task(A)
\end{verbatim}
Ideally, we would like to detect the dependency induced by \verb|A.attribute| with no synchronizations in the master, and then get the full object in the worker. This means that the programming should:
\begin{enumerate}
\item Detect the data dependency (introspection)
\item Ask for \verb|A|, and \verb|A.attribute|
\item Deserialize \verb|A| and \verb|A.attribute|, realize that one object is an attribute of the other, and add it
\end{enumerate}
These steps require a heavy implementation with a noticeable performance impact. For example, a $2000 \times 2000$ \verb|numpy.matrix| can make the programming model iterate through $4000000$ elements unnecessarily.\\
\\
However, this use case is pretty common, so something must be done. So our goal is now to determine what can be implemented within the existing time and viability constraints.\\
\\
After some meetings it was decided that support for arrays should be implemented in the COMPSs Programming Model. Given that many COMPSs users find words like \textit{array, hash map, reflection, inheritance} complicated and misleading it was decided to call this feature as \textit{support for collections}, as collection is a word that seemed more understandable by non computer science researchers. This name also gives the opportunity to extend this implementation to other iterable data structures such as sets, hash maps and so on.\\
\\
This feature should cover these two cases:
\begin{verbatim}
L = [future_object_1, future_object_2, ...]
y = f(L) # Future objects should be synced and available
\end{verbatim}

\begin{verbatim}
L = [object_1]
modify_object_1()
f(L) # object_1 should be updated and synced properly
\end{verbatim}
In other words, collections should support both IN and INOUT objects.\\
\\
This feature is especially interesting because its implementation serves two purposes: usability and performance. With no collections users are forced to use some \textit{alternative tricks} such as functions with the signature \verb|f(*args)| to deceive the programming model into believing that it is receiving multiple arguments. As we will see later, this particular trick has its own problems and issues.

\subsection{Collections as Input Parameters}
\label{subsec:col_in}
The first step consists of enabling the COMPSs Programming Model to accept collections fully composed of input parameters. This step will also help us to identify and to mark all the parts that require some implementation and/or modification when dealing with this feature.\\
\\
The easiest way to implement this feature is by what we call the \textit{contagion model}. Note that, in terms of dependencies, if some object $x$ is contained in some collection $C$ then any dependency that affects $C$ must also affect $x$, and vice versa. Let's consider the following pseudo-code:

\begin{verbatim}
c1 = f() # c1 is a future object
C = [c1, ...] # C contains a future objects and possibly more thing
g(C)
\end{verbatim}
There is a clear dependency between the function calls $g(C)$ and $f()$. The easiest way to implement this is to recursively iterate collection objects and to process each object as a single parameter. This approach still offers some room to improve performance. For example, it is not necessary to transfer certain metadata of each single element of a collection, as it can be deduced or inherited from the collection object per se. In this first case, it is not necessary to specify that the direction of all the elements $c_1, ..., c_n$ of some input collection $C$ is \verb|IN|, as it can be deduced from the fact that $C$ is an input collection.\\
\\
Once we have decided what we want to implement we must decide how and where to start. Our chosen approach is something similar to what is called TDD (Test Driven Development) \footnote{https://en.wikipedia.org/wiki/Test-driven\_development}: we wrote a PyCOMPSs app that uses collections as input parameters and now we want to make it work. The source code can be found in appendix \ref{subsec:col_in}.

As we mentioned in section \ref{subsec:compss_components}, the design of the programming model forces the developer to go through many layers of the software just to implement a single feature. Any PyCOMPSs parameter will go through the pipeline shown in figure \ref{fig:parameter_pipeline}.

\begin{figure}[ht!]
\centering
\includegraphics[scale = 0.5]{figures/parameter_pipeline.png}
\caption{The journey of a Python parameter, from the user's function call until the task in finished in the worker}
\label{fig:parameter_pipeline}
\end{figure}

In the following sections we will explain how the implementation of this feature affected all of the parts that appear in figure \ref{fig:parameter_pipeline}.

\subsubsection{Python Binding}
\label{subsubsec:python_binding_col_in}
This part covers intercepting the user's call to a PyCOMPSs task, the serialization of the task parameters (if necessary) and the forwarding of the necessary metadata to the Java Runtime.\\
\\
The very first step, and the easiest one, consists of adding a \verb|COLLECTION_IN| annotation in the list of annotations. This part is as easy as copy-pasting any of the existing parameters and then adapting it to our needs:

\inputminted{python}{snippets/param_col_in.py}

In fact, copy-pasting the specifications of the \verb|IN| parameter in more than enough. It is also necessary to add the type \verb|COLLECTION| in an inter-language type list which is after replicated in the three programming languages.\\
\\
The second step consists of serializing all the necessary data.

\inputminted{python}{snippets/serialize_object_into_file.py}

As we can see in the snippet, our implementation is just a recursive call to an already existing function devoted to serialize objects.

\subsubsection{C/C++ Bindings Common}
\label{subsubsec:bindings_common_col_in}
All metadata regarding parameters is produced by the corresponding binding (in our case, PyCOMPSs) and then translated to something understandable by the COMPSs runtime. This is achieved by extending Python with C++ and then sending messages via JNI (Java Native Interface \footnote{https://en.wikipedia.org/wiki/Java\_Native\_Interface}). In the case of the collection parameters it was decided to forward, from Python to Java, the following information:

\begin{verbatim}
collectionId N
type1 Val1
...
typeN ValN
\end{verbatim}

Note that if the $ith$ parameter is a collection then $val_i$ will contain the whole sub-collection.

\subsubsection{Runtime/Master (Java)}
\label{subsubsec:runtime_master_col_in}

%TODO: COLLECT DEPENDENCY GRAPH FROM MN3

\subsubsection{Runtime/Worker (Java)}
\label{subsubsec:runtime_worker_col_in}

\subsubsection{Python Worker}
\label{subsubsec:python_worker_col_in}
This last step is probably the easiest one. 


\subsection{Collections as INOUT Parameters}
\label{subsec:col_inout}

\subsection{Practical Applications}
\label{subsec:col_examples}
\input{hyperloglog.tex}