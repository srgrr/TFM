\newpage
\section{Fixing tasks overheads in PyCOMPSs}
\label{sec:task_overhead}
This first section describes a performance fix in the COMPSs programming model. Its intention is to give a practical example of how important is to properly manage objects in distributed programming models and to show how complex and long finding a bug can be.

\subsection{Problem description}
A COMPSs user reported via mailing list that his application showed a gradual performance degradation over time. The workflow of his application can be summarized as follows:

\inputminted{python}{applications/TASK_OVERHEAD/main.py}

The user was able to detect this performance degradation thanks to the tracing tools. A trace showing this issue can be found in figure \ref{fig:trace_task_degradation}

% TODO: ADD TRACE FIGURE

\subsection{Analysing and narrowing down the problem}
The trace from figure \ref{fig:trace_task_degradation} gives us the hint that there is something wrong about-
% TODO: COMPLETE THIS SECTION, EXPLAIN HOW WE DID ARRIVE TO IDOBJ

\subsection{Object identification and mapping in PyCOMPSs}
Now we know that the main source of this overhead comes from the \verb|get_object_id| function from the PyCOMPSs source code. Let's take a look at this function:

\inputminted{python}{snippets/get_object_id_old.py}

This function iterates over potentially all of the tracked objects just to get the identifier of some object (or to assign it one). This is done this way because an object needs to be hashable for being used as a key in a dictionary. Hashable usually means immutable, and no user can guarantee us that his objects will fulfill these properties. In fact, the programming model supports INOUT objects, which are, by nature, mutable objects. Some examples of mutable Python objects are \verb|[1, 2, 3, "hello"]|, \verb|object()| and \verb|numpy.random.rand(5)|.\\
\\
A possible fix may consist of using the \verb|id| function. This function accepts an object as its unique argument and returns its memory address.

% TODO: COMPLETE THIS SECTION, SHOW A TRACE WITH THE PERFORMANCE UPGRADE
% TODO: ADD REFERENCES TO CLOC
The overall performance gain was, as shown in figure \ref{fig:task_performance_after}, enourmous. Although the final implementation consisted of a few lines of source code, it was arguably hard to find where this improvement should be made. We must note that COMPSs has, according to the \verb|cloc| tool, around 300000 source lines of code (sloc).
